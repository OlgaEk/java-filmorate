# java-filmorate
Template repository for Filmorate project.

Файл с картинкой ER-схемы БД Filmorate находится в ветке add-friends-likes в папке 
java-filmorate/src/main/resources/QuickDBD-export.png



![QuickDBD-export](https://github.com/OlgaEk/java-filmorate/blob/add-friends-likes/src/main/resources/QuickDBD-export.png)

Я приняла решение хранить в отдельных таблицах данные пользователей (USER) и данные о фильмах (FILM).

Так же в отдельных таблицах хранится рейтинг фильма (RATING), жанр фильма (GENRE) и статус дружбы (STATUS_OF_FRIEND) - это позволит просто заменять названия рейтингов, жанров   и статуса.

Таблица USER_FRIEND хранит данные о проведенных и подтвержденных пользователем запросов на дружбу. Ключом выступает идентификатор записи.
Реализация взаимной дружбы будет происходить на уровне приложения. При поступлении запроса на дружбу будет формироваться две строки в таблице USER_FRIEND:
          - одна о дружбе между User1 и User2,
          - вторая о дружбе между User2 и User1.
          
Таблица FILM_LIKE будет соединительной для таблиц FILM и USER. В этой таблице связывается идентификатор понравившегося фильма с идентификатором пользователя, причём каждая такая пара будет уникальной (это составной ключ).

Примеры запросов:
 - получение всех фильмов 
```
 SELECT name
 
 FROM film
```
 
 
 - получение всех пользователей
```
 SELECT name
 
 FROM user
 ```
 
 
 -получение 10 наиболее популярных фильмов
 ```
 SELECT f.name,
 
        COUNT (fl.user_id)
        
 FROM film_like AS fl LEFT INNER JOIN film AS f ON fl.film_id = f.film_id
 
 GROUP BY fl.film_id
 
 ORDER BY COUNT(fl.user_id) DESC
 
 LIMIT 10 
 ```
 
 
 -получение списка общих друзей для user1(id=1) и user2(id=2)
```
 SELECT u.name
 
 FROM user_friend AS uf
 
 LEFT OUTER JOIN user AS u ON u.user_id = uf.user_friend_id
 
 WHERE uf.user_id = 1
 
 AND user_friend_id IN (SELECT uf.user_friend_id
 
                          FROM uf
                          
                          WHERE uf.user_id = 2)
```                        
 
 
 -- Комментарии Кучинского Александра от 03.07.2022 к схеме:
По твоей схеме:
1) смущает использование типов int2 и int4. Вот здесь https://postgrespro.ru/docs/postgresql/9.6/datatype-numeric написано "Имена типов int2, int4 и int8 выходят за рамки стандарта, хотя могут работать и в некоторых других СУБД." Кажется что Постгресс не работает с такими типами.
2) Кажется, хорошо что вынесла статус в отдельную таблицу, так будет проще управлять статусной моделью. Я же себя сразу ограничил boolean, что вероятнее всего приведет к необходимости рефакторить это в будущем.
3) Смущает что связь таблицы "дружбы" по user_friend_id с user_id из таблица user как многие к одному. Это корректно? Я у себя делал связь один к одному, сижу думаю...
4) По запросам. Глядя на твои запросы, переписал свои про топ фильмов (рейтинг я не тот использовал, да, спасибо). По последнему запросу: не уверен, что во вложенном селекте можно использовать псевдоним uf из основного селекта (я так понял что сначала выполнится вложенные селект, а потом основной), но могу ошибаться, я так не пробовал. В остальном, наверное, запрос сработает. Во всех запросах в конце не хватает точки с запятой (супер важное замечание=)).
 
По пункту 3 связь логичная, вопрос снимаю

ОТвет
1) Да, сейчас почитала информацию по ссылке и теперь заменю все типы int2 и int4  на integer
4) https://postgrespro.ru/docs/postgresql/9.6/queries-table-expressions#queries-where Указано, что название таблицы, порождённой в предложении FROM используется в подзапросах.
